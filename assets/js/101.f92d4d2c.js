(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{520:function(v,_,t){"use strict";t.r(_);var e=t(20),o=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"场与矩阵"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#场与矩阵"}},[v._v("#")]),v._v(" 场与矩阵")]),v._v(" "),t("p",[v._v("在 Taichi 中，场是全局变量。 场又分为稀疏场和稠密场。 一个场的元素可以是标量，也可以是向量或矩阵。")]),v._v(" "),t("div",{staticClass:"custom-block note"},[t("p",{staticClass:"custom-block-title"},[v._v("注解")]),v._v(" "),t("p",[v._v("矩阵可以被用作场的元素，因此你可以创建每一个元素都是矩阵的场。")])]),v._v(" "),t("h2",{attrs:{id:"标量场"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标量场"}},[v._v("#")]),v._v(" 标量场")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("每一个全局变量都是一个 N-维场。")]),v._v(" "),t("ul",[t("li",[v._v("全局"),t("code",[v._v("标量")]),v._v("被视为 0-维的标量场。")])])]),v._v(" "),t("li",[t("p",[v._v("我们始终使用索引来访问场")]),v._v(" "),t("ul",[t("li",[v._v("例如： 如果"),t("code",[v._v("x")]),v._v(" 是一个 3 维标量场，则"),t("code",[v._v("x[i, j, k]")]),v._v("。")]),v._v(" "),t("li",[v._v("即使访问 0 维场 "),t("code",[v._v("x")]),v._v("，也应使用 "),t("code",[v._v("x[None] = 0")]),v._v(" 而不是 "),t("code",[v._v("x = 0")]),v._v("。 请"),t("strong",[v._v("始终")]),v._v("使用索引访问场中的元素。")])])]),v._v(" "),t("li",[t("p",[v._v("场的元素初始值全部为 0。")])]),v._v(" "),t("li",[t("p",[v._v("稀疏场元素的初始状态是未被激活的。")])]),v._v(" "),t("li",[t("p",[v._v("请查看"),t("RouterLink",{attrs:{to:"/zh/docs/develop/documentation/api/scalar_field.html"}},[v._v("标量场")]),v._v("这一章节来了解更多详细信息。")],1)])]),v._v(" "),t("h2",{attrs:{id:"矩阵场"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#矩阵场"}},[v._v("#")]),v._v(" 矩阵场")]),v._v(" "),t("p",[v._v("场的元素可以是矩阵。")]),v._v(" "),t("p",[v._v("假设你有一个名为 "),t("code",[v._v("A")]),v._v(" 的 "),t("code",[v._v("128 x 64")]),v._v(" 的场，每一个元素都包含一个形状为 "),t("code",[v._v("3 x 2")]),v._v(" 的矩阵。 要分配每一个元素都是一个 "),t("code",[v._v("3 x 2")]),v._v(" 矩阵的形状为 "),t("code",[v._v("128 x 64")]),v._v(" 的矩阵场，请使用声明 "),t("code",[v._v("A = ti.Matrix.field(3, 2, dtype=ti.f32, shape=(128, 64))")]),v._v("。")]),v._v(" "),t("ul",[t("li",[v._v("如果你想获取网格节点 "),t("code",[v._v("i, j")]),v._v(" 上的矩阵，请使用 "),t("code",[v._v("mat = A[i, j]")]),v._v("。 "),t("code",[v._v("mat")]),v._v(" 是一个 "),t("code",[v._v("3 x 2")]),v._v(" 的矩阵")]),v._v(" "),t("li",[v._v("要获取第 1 行第 2 列的矩阵元素，请使用 "),t("code",[v._v("mat[0, 1]")]),v._v(" 或者 "),t("code",[v._v("A[i, j][0, 1]")]),v._v("。")]),v._v(" "),t("li",[v._v("你可能已经注意到，当你从全局矩阵场加载矩阵元素时会有"),t("strong",[v._v("两个")]),v._v("索引运算符 "),t("code",[v._v("[]")]),v._v("：第一个用于场索引，而第二个则用于矩阵索引。")]),v._v(" "),t("li",[t("code",[v._v("ti.Vector")]),v._v(" 其实只是 "),t("code",[v._v("ti.Matrix")]),v._v(" 的别名。")]),v._v(" "),t("li",[v._v("有关矩阵的更多信息，请参见 "),t("RouterLink",{attrs:{to:"/zh/docs/develop/documentation/api/matrix.html"}},[v._v("Matrices")]),v._v(" 。")],1)]),v._v(" "),t("h2",{attrs:{id:"矩阵尺寸"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#矩阵尺寸"}},[v._v("#")]),v._v(" 矩阵尺寸")]),v._v(" "),t("p",[v._v("出于性能原因，矩阵操作的运算将被展开，因此我们建议仅使用小型的矩阵。 例如，"),t("code",[v._v("2x1")]),v._v("，"),t("code",[v._v("3x3")]),v._v("，"),t("code",[v._v("4x4")]),v._v(" 大小的矩阵运算还好，但"),t("code",[v._v("32x6")]),v._v(" 作为矩阵的大小可能过大了。")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),t("p",[v._v("由于展开机制的存在，在大型矩阵（例如 "),t("code",[v._v("32x128")]),v._v(" ）上进行操作会导致很长的编译时间并带来较低的性能。")])]),v._v(" "),t("p",[v._v("如果你的矩阵的某维度很大（例如 "),t("code",[v._v("64")]),v._v(" ），则最好定义一个大小为 "),t("code",[v._v("64")]),v._v(" 的场。 例如，声明一个 "),t("code",[v._v("ti.Matrix.field(64, 32, dtype=ti.f32, shape=(3, 2))")]),v._v(" 是不合理的，可以试着用 "),t("code",[v._v("ti.Matrix.field(3, 2, dtype=ti.f32, shape=(64, 32))")]),v._v(" 来代替。 始终把大的维度放在场中而非矩阵中。")])])}),[],!1,null,null,null);_.default=o.exports}}]);