(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{492:function(t,a,s){"use strict";s.r(a);var n=s(20),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"taichi-内核的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#taichi-内核的生命周期"}},[t._v("#")]),t._v(" Taichi 内核的生命周期")]),t._v(" "),s("p",[t._v("有时了解一个 Taichi 内核的生命周期会有所帮助。 简而言之，编译只会在第一次调用一个内核实例时发生。")]),t._v(" "),s("p",[t._v("一个 Taichi 内核的生命周期有如下几个阶段：")]),t._v(" "),s("ul",[s("li",[t._v("内核注册")]),t._v(" "),s("li",[t._v("模板实例化和缓存")]),t._v(" "),s("li",[t._v("Python 抽象语法树转换(AST: [Abstact Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree))")]),t._v(" "),s("li",[t._v("Taichi 中间表示代码编译，优化和可执行文件生成")]),t._v(" "),s("li",[t._v("启动")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/taichi-dev/public_files/fa03e63ca4e161318c8aa9a5db7f4a825604df88/taichi/life_of_kernel.png",alt:"图像"}})]),t._v(" "),s("p",[t._v("让我们考虑以下简单内核：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token decorator annotation punctuation"}},[t._v("@ti"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("kernel")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ti"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("template"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" delta"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ti"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("i32"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" delta\n")])])]),s("p",[t._v("我们分配了两个1维场以简化讨论：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[t._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ti"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dtype"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("ti"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("f32"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" shape"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("128")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ny "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ti"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dtype"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("ti"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("f32"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" shape"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h2",{attrs:{id:"内核注册"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内核注册"}},[t._v("#")]),t._v(" 内核注册")]),t._v(" "),s("p",[t._v("当执行 "),s("code",[t._v("ti.kernel")]),t._v(" 装饰器时，将注册一个名为 "),s("code",[t._v("add")]),t._v(" 的内核。 具体来说，Taichi将记住 "),s("code",[t._v("add")]),t._v(" 函数的 Python 抽象语法树(AST)。 在第一次调用 "),s("code",[t._v("add")]),t._v(" 之前不会进行编译。")]),t._v(" "),s("h2",{attrs:{id:"模板实例化和缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模板实例化和缓存"}},[t._v("#")]),t._v(" 模板实例化和缓存")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[t._v("add"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("第一次调用 "),s("code",[t._v("add")]),t._v(" 时， Taichi 前端编译器将实例化内核。")]),t._v(" "),s("p",[t._v("当你以相同的"),s("strong",[t._v("模板签名(template signature)")]),t._v("（稍后说明）进行第二次调用时，例如，")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[t._v("add"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Taichi 将直接重复使用之前编译的二进制文件。")]),t._v(" "),s("p",[t._v("用 "),s("code",[t._v("ti.template()")]),t._v(" 提示的参数是模板参数，将引起模板实例化。 例如，")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[t._v("add"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("将导致 "),s("strong",[t._v("add")]),t._v(" 的新实例化。")]),t._v(" "),s("div",{staticClass:"custom-block note"},[s("p",{staticClass:"custom-block-title"},[t._v("注解")]),t._v(" "),s("p",[s("strong",[t._v("模板签名")]),t._v("可以区分一个内核模板的不同实例。 "),s("code",[t._v("add(x, 42)")]),t._v(" 的签名是 "),s("code",[t._v("(x, ti.i32)")]),t._v(" ，这与 "),s("code",[t._v("add(x, 1)")]),t._v(" 的签名相同。 因此，后者可以重用之前编译的二进制文件。 "),s("code",[t._v("add(y, 42)")]),t._v(" 的签名是 "),s("code",[t._v("(y, ti.i32)")]),t._v("，与之前 x 的签名不同，因此一个新的内核将被实例化和编译。")])]),t._v(" "),s("div",{staticClass:"custom-block note"},[s("p",{staticClass:"custom-block-title"},[t._v("注解")]),t._v(" "),s("p",[t._v("Taichi 标准库中的许多基本操作都是使用 Taichi 内核和元编程技巧实现的。 调用它们将导致"),s("strong",[t._v("隐式内核实例化(implicit kernel instantiations)")]),t._v("。")]),t._v(" "),s("p",[t._v("示例包括 "),s("code",[t._v("x.to_numpy()")]),t._v(" 和 "),s("code",[t._v("y.from_torch(torch_tensor)")]),t._v("。 调用这些函数时，你将看到内核实例化，因为 Taichi 内核们将被生成，以来把繁重的工作分流给多个 CPU 内核/ GPU。")]),t._v(" "),s("p",[t._v("如前所述，第二次调用相同的操作时，缓存的已编译内核将被重用，并且不需要进一步的编译。")])]),t._v(" "),s("h2",{attrs:{id:"代码转换和优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码转换和优化"}},[t._v("#")]),t._v(" 代码转换和优化")]),t._v(" "),s("p",[t._v("当一个新的实例化发生时，Taichi 的前端编译器（即 Python 类 "),s("code",[t._v("ASTTransformer")]),t._v(" ）将把内核函数体的 AST 转换为 Python 脚本，当该脚本执行时会输出一个 Taichi 前端 AST。 大体上讲，得益于我们应用在 Python AST 上的一些补丁，使得 Taichi 前端可以识别它。")]),t._v(" "),s("p",[t._v("AST 的降阶过程 (lowering pass) 会将前端的中间表示代码转换为分层静态单任务 (SSA: [Static Single Assignment](https://en. wikipedia. org/wiki/Static_single_assignment_form) 的中间表示代码，从而允许一系列过程更进一步地处理中间表示代码，例如")]),t._v(" "),s("ul",[s("li",[t._v("循环向量化")]),t._v(" "),s("li",[t._v("类型推断和检查")]),t._v(" "),s("li",[t._v("一般简化，例如通用子表达式消除(CSE)，无效指令消除(DIE)，常数折叠和存储转发")]),t._v(" "),s("li",[t._v("降低访问权限")]),t._v(" "),s("li",[t._v("数据访问优化")]),t._v(" "),s("li",[t._v("反向模式自动微分（如果使用微分编程）")]),t._v(" "),s("li",[t._v("并行化和卸载")]),t._v(" "),s("li",[t._v("原子操作降级")])]),t._v(" "),s("h2",{attrs:{id:"即时-jit-编译引擎"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#即时-jit-编译引擎"}},[t._v("#")]),t._v(" 即时（JIT）编译引擎")]),t._v(" "),s("p",[t._v("最后，优化后的 SSA IR 被输入后端编译器，如 LLVM 或 Apple Metal/OpenGL 着色器编译器。 然后后端编译器生成高性能可执行的 CPU/GPU 程序。")]),t._v(" "),s("h2",{attrs:{id:"内核启动"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内核启动"}},[t._v("#")]),t._v(" 内核启动")]),t._v(" "),s("p",[t._v("Taichi 内核最终将作为多线程 CPU 任务或 CUDA 内核启动。")])])}),[],!1,null,null,null);a.default=e.exports}}]);